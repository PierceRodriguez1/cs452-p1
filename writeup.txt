CSC 452/552 Operations Systems
Project 2 The Classic Bounded Buffer Problem
Name:Pierce Rodriguez
Bronco ID: 114203816
Date: 22 October 2024

1.	Project Overview
a)	In this project you will implement a FIFO queue as a monitor that can be used to solve the bounded buffer problem.
Your queue will have a fixed capacity and will block calling threads when it is full or empty. Bounded buffers are extremely 
common in Operating Systems. When you write code in Java, Python, C#, etc. it may seem like you have infinite memory. However,
 infinite memory is just an abstraction that the OS provides, in reality you are limited by the physical hardware the OS is running on.
  This data structure could be used to build higher level abstractions like a thread pool.

2.	Project Management Plan
a)	Task 1: Setup
b)	Task 2: Prepare your repository 
c)	Task 3: implement the header file
d)	Task 4: Submit your code
3.	Project Deliveries
a)	How to compile and use my code?
i.	Use commands in this order
	Make
	./myprogram
b)	Any self-modification?
	-c: number of consumer threads
	-p number of producer threads
    -I number of items per producer
	-s Queue size
	-d enable random delays
c)	Summary of Results.
i.	tests/test-lab.c:78:test_create_destroy:PASS
tests/test-lab.c:79:test_queue_dequeue:PASS
tests/test-lab.c:80:test_queue_dequeue_multiple:PASS
tests/test-lab.c:81:test_queue_dequeue_shutdown:PASS

-----------------------
4 Tests 0 Failures 0 Ignored 
OK
4.	Self-Reflection of Project 2
This project really showed the importance of careful synchronization in multi-threaded programs. 
In the beginning I was getting inconsistent results because threads were not being properly synchronized. 
That helped me understand that without meticulous synchronization a program can given random results as
 threads access shared resources. Additionally, I learned the significance of proper resource cleanup and shutdown. 
 Resource leaks from incomplete shutdowns caused issues that reinforced the need for careful management of memory, 
 file handles, and thread pools. I also gained practical insight into the monitor concept, where implementing monitors 
 for thread synchronization helped me better grasp mutual exclusion and critical section management. These experiences 
 collectively deepened my understanding of multi-threaded programming and the importance of robust resource management 
 and synchronization techniques.

